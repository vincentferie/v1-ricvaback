import { Injectable, HttpException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { TypeOrmHttpParamQuery } from 'src/helpers/core/typeorm-query';
import { isDefined } from 'class-validator';
import { responseRequest } from 'src/helpers/core/response-request';
import { AccountModel } from './account.model';
import { ILike, Repository } from 'typeorm';
import { SoftDelete } from 'src/helpers/enums/softdelete.enum';
import { AccountEntity } from './account.entity';
import { AccountRepository } from './account.repository';
import { AccountDto } from './account.dto';
import * as bcrypt from "bcrypt";
import { accountSeed } from 'src/seeders/fakers';

@Injectable()
export class AccountsService {

    constructor(
        //  Ci apres S'utilise avec un fichier repository. Mais ne peut plus creer de methode save update...
        // @InjectRepository(ProfilRepository) private accountRepository: ProfilRepository, 
        // Ci apres S'utilise sans fichier repository
        @InjectRepository(AccountEntity) private readonly accountRepository: Repository<AccountEntity>,
        @InjectRepository(AccountRepository) private readonly accountRepositoryFile: AccountRepository,
    ) { }

    async save(payload: any, input: AccountModel): Promise<AccountEntity> {
        let result: any, exception: any;
        try {
            result = await this.accountRepositoryFile.createDetail(input as AccountDto);
            if (isDefined(result)) {
                exception = await responseRequest({
                    status: 'inserted',
                    data: result,
                    params: null
                });
            }

        } catch (error) {
            if (error.code === '23505') {
                // Duplucate 
                exception = await responseRequest({
                    status: 'errorInserted',
                    data: result,
                    params: error.detail
                });
            } else if (error.code === '22001') {
                exception = await responseRequest({
                    status: 'errorPayload',
                    data: result,
                    params: `${error.length} mots saisies excèdent la limite de taille autorisée.`
                });
            } else {
                exception = await responseRequest({
                    status: 'errorOtherRequest',
                    data: error,
                    params: error.message
                });
            }
        }

        throw new HttpException(exception[0], exception[1]);
    }

    async update(payload: any, input: AccountModel, primaryKey: string): Promise<AccountEntity> {
        let exception: any, result: any;
        const response = await this.checkById(primaryKey);

        if (!isDefined(response)) {
            exception = await responseRequest({
                status: 'errorFound',
                data: response,
                params: `Aucun element ne correspont au paramètre ${primaryKey}`
            });
            throw new HttpException(exception[0], exception[1]);
        }

        try {
            if(input.password && input.password !== ''){
                input.password = await this.hashPassword(input.password, response.data.salt);
            }
            response.data.updated = new Date(Date.now());            
            result = await this.accountRepository.save({ ...response.data, ...input });

            if (isDefined(result)) {
                exception = await responseRequest({
                    status: 'updated',
                    data: result,
                    params: null
                });
            }

        } catch (error) {
            exception = await responseRequest({
                status: 'errorUpdated',
                data: result,
                params: error
            });
        }

        throw new HttpException(exception[0], exception[1]);
    }

    async updateMode(payload: any, primaryKey: string, mode: SoftDelete): Promise<AccountEntity> {
        let exception: any, result: any;
        const response = await this.checkById(primaryKey);

        if (!isDefined(response)) {
            exception = await responseRequest({
                status: 'errorFound',
                data: response,
                params: `Aucun element ne correspont au paramètre ${primaryKey}`
            });
            throw new HttpException(exception[0], exception[1]);

        }

        try {
            response.data.mode = mode;
            response.data.updated = new Date(Date.now());
            response.data.updated_by = `${payload.user.nom} ${payload.user.prenoms}`;
            result = await this.accountRepository.save(response.data);

            if (isDefined(result)) {
                exception = await responseRequest({
                    status: 'updated',
                    data: result,
                    params: null
                });
            }

        } catch (error) {
            exception = await responseRequest({
                status: 'errorUpdated',
                data: result,
                params: error
            });
        }

        throw new HttpException(exception[0], exception[1]);

    }

    async delete(payload: any, primaryKey: string): Promise<void> {
        let exception: any, result: any;
        const response = await this.checkById(primaryKey);

        if (!isDefined(response)) {
            exception = await responseRequest({
                status: 'errorFound',
                data: response,
                params: `Aucun element ne correspont au paramètre ${primaryKey}`
            });
            throw new HttpException(exception[0], exception[1]);

        }
        try {
            result = await this.accountRepository.delete(primaryKey);

            if (isDefined(result)) {
                exception = await responseRequest({
                    status: 'deleted',
                    data: result,
                    params: null
                });
            }

        } catch (error) {
            exception = await responseRequest({
                status: 'errorDeleted',
                data: result,
                params: error
            });
        }

        throw new HttpException(exception[0], exception[1]);

    }

    async softDelete(payload: any, primaryKey: string): Promise<void> {
        let exception: any, result: any;
        const response = await this.checkById(primaryKey);

        if (!isDefined(response)) {
            exception = await responseRequest({
                status: 'errorFound',
                data: response,
                params: `Aucun element ne correspont au paramètre ${primaryKey}`
            });
            throw new HttpException(exception[0], exception[1]);

        }

        try {
            response.data.mode = SoftDelete.disable;
            response.data.updated = new Date(Date.now());
            response.data.updated_by = `${payload.user.nom} ${payload.user.prenoms}`;
            result = await this.accountRepository.save(response.data);

            if (isDefined(result)) {
                exception = await responseRequest({
                    status: 'deleted',
                    data: result,
                    params: null
                });
            }

        } catch (error) {
            exception = await responseRequest({
                status: 'errorDeleted',
                data: result,
                params: error
            });
        }

        throw new HttpException(exception[0], exception[1]);
    }

    async find(payload: any, query: object): Promise<AccountEntity[]> {
        let exception: any, result: any;

        try {
            const queryObject = Object.keys(query).length > 0 ? TypeOrmHttpParamQuery(query) : {
                relations:['role', 'groupement'],
                where : [{mode: SoftDelete.active}]
            };
            result = await this.accountRepository.find(queryObject);

            if (isDefined(result)) {
                exception = await responseRequest({
                    status: 'foundQuery',
                    data: result,
                    params: result.length
                });
            }

        } catch (error) {
            if (error.code === '22P02') {
                exception = await responseRequest({
                    status: 'errorFound',
                    data: result,
                    params: error.message
                });
            } else {
                exception = await responseRequest({
                    status: 'errorOtherRequest',
                    data: error,
                    params: `Erreur de paramètre ${JSON.stringify(query)}`
                });
            }
        }
        throw new HttpException(exception[0], exception[1]);

    }

    async findPaginate(payload: any, query: any): Promise<AccountEntity[]>{
        let exception: any, result: any, total: number;
        try {
            [result, total] = await this.accountRepository.findAndCount({
                relations:['role', 'groupement'],
                where: [
                    {
                        mode: SoftDelete.active
                    }
                ],
                order: {
                    nom: query.order ?? 'ASC', 
                    prenoms: query.order ?? 'ASC',
                    created: query.order ?? 'DESC'
                },
                skip: +query.offset,
                take: +query.take,
                cache: 60000
            });

            if (isDefined(result)) {
                exception = await responseRequest({
                    status: 'foundQuery',
                    data: result,
                    params: result.length
                });
                // Set Meta Pagination information
                exception[0].response.meta = {
                    itemCount: total,
                    totalItems: total,
                    itemsPerPage: +query.take,
                    totalPages: Math.floor(total / +query.take),
                    currentPage: (+query.offset + 1),
                };
                
            }

        } catch (error) {
            if (error.code === '22P02') {
                exception = await responseRequest({
                    status: 'errorFound',
                    data: result,
                    params: error.message
                });
            } else {
                exception = await responseRequest({
                    status: 'errorOtherRequest',
                    data: error,
                    params: `Erreur de paramètre ${JSON.stringify(query)}`
                });
            }
        }
        throw new HttpException(exception[0], exception[1]);

    }
    
    async findPaginateResearch(payload: any, query: any): Promise<AccountEntity[]>{
        let exception: any, result: any, total: number;
        try {
                [result, total] = await this.accountRepository.findAndCount({
                                                relations:['groupement', 'role'],
                                                where:[
                                                    {
                                                        nom: ILike(`%${query.query}%`),
                                                        superviseur_id: payload.user.id, 
                                                        mode: SoftDelete.active
                                                    },
                                                    {
                                                        prenoms: ILike(`%${query.query}%`),
                                                        superviseur_id: payload.user.id, 
                                                        mode: SoftDelete.active
                                                    },
                                                    {
                                                        contact: ILike(`%${query.query}%`),
                                                        superviseur_id: payload.user.id, 
                                                        mode: SoftDelete.active
                                                    },
                                                    {
                                                        username: ILike(`%${query.query}%`),
                                                        superviseur_id: payload.user.id, 
                                                        mode: SoftDelete.active
                                                    }
                                                ],
                                                order: { 
                                                    nom: query.order ?? 'ASC',
                                                    created: query.order ?? 'DESC'
                                                },
                                                skip: +query.offset,
                                                take: +query.take,
                                                cache: 60000
                                            });


            if (isDefined(result)) {
                exception = await responseRequest({
                    status: 'foundQuery',
                    data: result,
                    params: result.length
                });
                // Set Meta Pagination information
                exception[0].response.meta = {
                    itemCount: total,
                    totalItems: total,
                    itemsPerPage: +query.take,
                    totalPages: Math.floor(total / +query.take),
                    currentPage: (+query.offset + 1),
                };                
            }

        } catch (error) {
            if (error.code === '22P02') {
                exception = await responseRequest({
                    status: 'errorFound',
                    data: result,
                    params: error.message
                });
            } else {
                exception = await responseRequest({
                    status: 'errorOtherRequest',
                    data: error,
                    params: `Erreur de paramètre ${JSON.stringify(query)}`
                });
            }
        }
        throw new HttpException(exception[0], exception[1]);

    }

    async findMode(payload: any, mode: SoftDelete): Promise<AccountEntity[]> {
        let exception: any, result: any;

        try {
            result = await this.accountRepository.find({ mode: mode });

            if (isDefined(result)) {
                exception = await responseRequest({
                    status: 'found',
                    data: result,
                    params: null
                });
            }
        } catch (error) {
            if (error.code === '22P02') {
                exception = await responseRequest({
                    status: 'errorFound',
                    data: result,
                    params: error.message
                });
            } else {
                exception = await responseRequest({
                    status: 'errorOtherRequest',
                    data: error,
                    params: `Erreur de paramètre ${mode}`
                });
            }
        }
        throw new HttpException(exception[0], exception[1]);

    }

    async findById(payload: any, primaryKey: string): Promise<AccountEntity> {
        let exception: any, result: any;

        try {
            result = await this.accountRepository.findOne({ id: primaryKey, mode: SoftDelete.active  });

            if (isDefined(result)) {
                exception = await responseRequest({
                    status: 'foundQuery',
                    data: result,
                    params: 1
                });
            } else {
                exception = await responseRequest({
                    status: 'errorFound',
                    data: result,
                    params: `Aucun ID ${primaryKey} n'existe dans la base`
                });
            }

        } catch (error) {

            if (error.code === '22P02') {
                exception = await responseRequest({
                    status: 'errorFound',
                    data: result,
                    params: error.message
                });
            } else {
                exception = await responseRequest({
                    status: 'errorOtherRequest',
                    data: error,
                    params: `Erreur de paramètre ${primaryKey}`
                });
            }
        }
        throw new HttpException(exception[0], exception[1]);
    }

    async checkById(primaryKey: string): Promise<any> {
        let exception: any, result: any;

        try {
            result = await this.accountRepository.findOne({ id: primaryKey });
            if (isDefined(result)) {
                exception = {
                    status: 202,
                    data: result,
                    params: null
                };

                return exception;
            }
        } catch (error) {
            if (error.code === '22P02') {
                exception = await responseRequest({
                    status: 'errorFound',
                    data: result,
                    params: error.message
                });
            } else {
                exception = await responseRequest({
                    status: 'errorOtherRequest',
                    data: error,
                    params: error.message //`Erreur de paramètre ${primaryKey}`
                });
            }
            throw new HttpException(exception[0], exception[1]);
        }
    }

    private async hashPassword(password: string, salt: string): Promise<string> {
        return bcrypt.hash(password, salt);
    }

    /**
    * Seed .
    *
    * @function
    */
   create(): Array<Promise<AccountEntity>> {
    return accountSeed.map(async (item: AccountModel) => {
        return await this.accountRepository
            .findOne({ username: item.username })
            .then(async dbresult => {
                // We check if a item already exists.
                // If it does don't create a new one.
                if (isDefined(dbresult)) {
                    return Promise.resolve(null);
                }
                return await this.accountRepositoryFile.createDetail(item as AccountDto);
            })
            .catch(error => Promise.reject(error));
        });
    }

}
